
https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/

https://minikube.sigs.k8s.io/docs/start/

Pull Request

    - First time PR creation runs pull_request_builder.yaml
    - Pushing a commit to an existing PR runs pull_request_builder.yaml
    - Merging an existing PR to develop/master runs continuous_deployment.yaml
    - Direct commit push to develop/master runs continuous_deployment.yaml

Release/Hotfix

    - First time release/hotfix creation against develop/master runs pull_request_builder.yaml
    - Pushing a commit to an existing release/hotfix runs pull_request_builder.yaml
    - Creating a new PR against the release/hotfix runs pull_request_builder.yaml
    - Pushing a commit to an existing PR that tracks a release/hotfix runs pull_request_builder.yaml
    - Merging an existing PR to a release/hotfix runs pull_request_builder.yaml
    - Direct commit push to release/hotfix runs pull_request_builder.yaml
    - Merging an existing release/hotfix to develop/master runs continuous_deployment.yaml
    - Merging an existing release/hotfix to develop/master in CLI and pushing develop/master runs continuous_deployment.yaml

Tag

    - Manually creating a tag does nt trigger any pipeline
    - Pushing a tag from local does not trigger any pipeline
    
Manual Deployment

    - Manually deploying a specific git ref (branch/tag/sha) to a specific environment

Others

    - Closed PRs will not trigger any pipeline
    - Rollback is same as manual deployment so deploy a previous tag

Setup

Add Docker secrets and Kube config to GitHub

This will let your workflow to push images to DockerHub registry.

    DOCKERHUB_USERNAME
    DOCKERHUB_TOKEN

This will let your workflows to deploy the application to your local K8S cluster.

    // Enable routing public requests to K8S API.
     
    $ kubectl proxy --disable-filter=true
    Starting to serve on 127.0.0.1:8001
    (Optionally $ kubectl proxy --port=8001 --accept-hosts='.*\.ngrok.io')

    // Expose kubectl proxy to the Internet with ngrok.
     
    $ ./ngrok http 127.0.0.1:8001
    Forwarding                    http://c309b9b1359f.ngrok.io -> http://127.0.0.1:8001
    Forwarding                    https://c309b9b1359f.ngrok.io -> http://127.0.0.1:8001

    // Create a modified copy of your local kube config.
     
    $ kubectl config view --flatten > ~/Desktop/kube_config
    Remove `certificate-authority-data` line
    Add `insecure-skip-tls-verify: true` line
    Replace `server` value to `https://c309b9b1359f.ngrok.io`
     
    Finally it should look like something like below.
    ```
    apiVersion: v1
    clusters:
    - cluster:
        insecure-skip-tls-verify: true
        server: https://c309b9b1359f.ngrok.io
      name: minikube
    contexts:
    - context:
        cluster: minikube
        user: minikube
      name: minikube
    current-context: minikube
    kind: Config
    preferences: {}
    users:
    - name: minikube
      user:
        client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0.......
        client-key-data: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0.......
    ```
     
    Copy this content into `KUBE_QA_CONFIG` GitHub secret. Also additional ones for the other environments.


Prepare local cluster

You have to repeat these steps for each three environments.

    // Create namespace
     
    kubectl create namespace pipeline-qa

    // Create application secrets for the deployment beforehand
     
    # ./Desktop/.env
    KEY=qa-secret
     
    $ kubectl --namespace=pipeline-qa create secret generic pipeline-secret --save-config --from-file=./Desktop/.env
    secret/pipeline-secret created
     
    $ kubectl --namespace=pipeline-qa get secret/pipeline-secret -o jsonpath='{.data}'
    {".env":"S0VZPXFhLXNlY3JldAo="}
    $ echo 'S0VZPXFhLXNlY3JldAo=' | base64 --decode
    KEY=qa-secret

Test

Assuming that you have completed all these steps then pull request builder and deployment succeeded. Lets test the API. Very first deployment will have two replicas however the consequent ones will have only one as we patch "rollout" annotation.

Cluster info

    $ kubectl --namespace=pipeline-qa get all
    NAME                                       READY   STATUS    RESTARTS   AGE
    pod/pipeline-deployment-5767699c9c-dzp2m   1/1     Running   0          26s
     
    NAME                       TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
    service/pipeline-service   ClusterIP   10.111.146.68           80/TCP    28s
    NAME                                  READY   UP-TO-DATE   AVAILABLE   AGE
    deployment.apps/pipeline-deployment   1/1     1            1           27s
    NAME                                             DESIRED   CURRENT   READY   AGE
    replicaset.apps/pipeline-deployment-5767699c9c   1         1         1       26s
    replicaset.apps/pipeline-deployment-5d5c66fcf6   0         0         0       27s

Logs

    $ kubectl --namespace=pipeline-qa logs pod/pipeline-deployment-5767699c9c-dzp2m
    2021/08/03 19:45:37 running pipeline: {com:3f07885 env:qa adr::8080 key:qa-secret}


Accessing the application

    $ kubectl --namespace=pipeline-qa port-forward service/pipeline-service 3000:80
    Forwarding from 127.0.0.1:3000 -> 8080
    Forwarding from [::1]:3000 -> 8080
    Handling connection for 3000

This is what you should get as a result.

    $ curl http://0.0.0.0:3000
    {com:3f07885 env:qa adr::8080 key:qa-secret}

minikube start --vm-driver="virtualbox" --insecure-registry="$REG_IP":80
